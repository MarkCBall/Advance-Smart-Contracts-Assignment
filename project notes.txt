
Remembers their last signed move to Player B and has calculated what board state player B starts with.

Player A triggers noValidMoveDispute if no move back received
Player A watches for opponent triggering a noValidMoveDispute

Player A is given a signed move which includes:
-The previous board state (uint256)
-A move (uint 256) piece#+new location
-A timestamp (blockNumber)
-A signature (V,R,S)

Player A then verifies the given previous board state is correct
-if not Player A triggers noValidMoveDispute

Player A then verifies that the move is valid
-call isValidMove function
-the timestamp is > their previous timestamp
-the signature is valid

Player A then calculates their current board state

Player A then gets user to select a move

Player A then timestamps and signs their board state and move



 calculates their current board state from from the signed previous board state 
-The board state they were given


Each player calculates the state of the board based on the previous player's state and their move

--------------------

MAIN CONTRACT   


mapping (uint -> game) games

struct gameState {
        uint x;
        uint x;
        uint x;
    }

//starting block#?
function InitChannel(
    address _addr1,
    //address _addr2,
    bytes _sig1,
    //bytes _sig2,
    uint _collateralAmt,
    address _disputeContractAddr,
    uint _gameID
)
//if gameID doesn't already exist
//withdraw funds from both parties
//check sig1 validates
//games[_gameID].collateralAmt = x2 withdrawn from Each
//games[_gameID].othervars should be set




function validateChannelSig(
    address _addr1,
    bytes _sig1,
    uint _collateralAmt,
    address _disputeContractAddr,
    uint _gameID
)
return isSig1 valid

Payout(uint _gameID, uint _addr1Amt)
if (msg.sender) = games[_gameID]._disputeContractAddr
if games[_gameID].collateralAmt < _addr1Amt
transfer games[_gameID].addr1 _addr1Amt and the rest to address2

---------------

DISPUTE CONTRACT

mapping (uint --> gameState) games

struct gameState {
        uint blockNum;
        uint boardState;
        uint latestMove;
        bool addr1MovedLast;
    }

constructor(address mainContract){
    owningcontract = address of main contract
}

function PostMove(
    uint latestState,
    uint currentMove,
    bytes signature
    ){
    require validateSig
    require validateMove
    set gameState
}
    
    
function CounterMove(uint _move)
    //calculateState
    // setGameState


function CounterMoveAndPost(uint _move, ...)
    //calls CounterMove
    //call PostMove

//getters after PostMove and CounterMoveAndPost

function noCounterInTime()
    if last move was >100 blocks ago
        winnerTriggers(xxx)

function winnerTriggered
    //main contract payout

function calculateState
    //validateMove
    //set state
        //make queen as appropriate

function validateMove
    return (isForward || isAttack || isDouble ||
    (isQueen && (isBack || isBackAttack)))
    //if simple move
    //if firstDoublemove
    //if attack
    //if queenBack
    //if queenAttackBackwards
        //return true
    //return false

//msg.sender + sig means we have two party signatures
function validateSig //modifier???
    address signingAddr = addressFromSig(xxx)
    bool msgSenderAddr1
    if msg.sender == address1{
        msgSenderAddr1 = true;
        require signingAddr = address2
    }
    else{
        require (msg.sender == address2 && signingAddr = address2)
    }

function addressFromSig
    //returns address


